{"ast":null,"code":"import { compileOptions, encode, fid, getPathFromRef, restrictTo } from './utils';\nimport { Document } from './Document';\nexport class Transaction {\n  constructor(db) {\n    this.db = db;\n    this.writes = [];\n    this.preconditions = {};\n  }\n  /**\n   * Creates a write instruction and adds it into the\n   * transaction writes array.\n   * @private\n   */\n\n\n  write(ref, data, options = {}) {\n    if (typeof data !== 'object') throw Error('The data argument is missing');\n    const transforms = [];\n    const name = `${this.db.rootPath}/${getPathFromRef(ref)}`;\n    const precondition = this.preconditions[name]; // Compile the JS Object into a Firebase Document.\n\n    const doc = encode(ref instanceof Document ? ref : data, transforms); // Compile the options object into Firebase API arguments.\n\n    options = compileOptions(options, data); // Check if there is any precondition created by getting a document\n    // as part of this transaction, and if there is then use it.\n\n    precondition && (options.currentDocument = precondition); // Set the document's name\n\n    doc.name = name; // Add the static properties.\n\n    this.writes.push({\n      update: doc,\n      ...options\n    }); // Add the Transforms if available.\n\n    transforms.length && this.writes.push({\n      transform: {\n        document: doc.name,\n        fieldTransforms: transforms\n      }\n    });\n  }\n  /**\n   * Wraps batch get with additional functionality needed in transactions.\n   * Transactions need to be atomic. So in order to know that the document\n   * wasn't changed concurrently then we save the updateTime of each document.\n   *\n   * Later we tell the database to use that as a precondition for the write.\n   * In other words, if the update time of a document changed, then abort\n   * the transaction. However, if a document didn't exist, then we use that\n   * as a precondition, telling the database that if it was created concurrently\n   * then it should abort the operation.\n   */\n\n\n  async get(refs) {\n    const docs = await this.db.batchGet(refs);\n    docs.forEach(doc => {\n      const {\n        name,\n        updateTime\n      } = doc.__meta__ || {\n        name: doc.__missing__\n      };\n      this.preconditions[name] = updateTime ? {\n        updateTime\n      } : {\n        exists: false\n      };\n    });\n    return docs;\n  }\n\n  add(ref, data, options = {}) {\n    const path = `${restrictTo('col', ref)}/${fid()}`;\n    this.write(path, data, {\n      exists: false,\n      ...options\n    });\n    return this.db.ref(path);\n  }\n\n  set(ref, data, options = {}) {\n    restrictTo('doc', ref);\n    this.write(ref, data, options);\n  }\n\n  update(ref, data, options = {}) {\n    restrictTo('doc', ref);\n    this.write(ref, data, {\n      exists: true,\n      updateMask: true,\n      ...options\n    });\n  }\n  /**\n   * Adds a delete operation to the transaction.\n   */\n\n\n  delete(ref, options = {}) {\n    const name = `${this.db.rootPath}/${restrictTo('doc', ref)}`;\n    options = compileOptions(options); // Check if there is any precondition created by getting a document\n    // as part of this transaction, and if there is then use it.\n\n    this.preconditions[name] && (options.currentDocument = this.preconditions[name]);\n    this.writes.push({\n      delete: name,\n      ...options\n    });\n  }\n  /**\n   * Commits the transaction.\n   * Will throw if the transaction failed.\n   */\n\n\n  async commit() {\n    this.preconditions = {};\n    return void (await this.db.fetch(this.db.endpoint + ':commit', {\n      method: 'POST',\n      body: JSON.stringify({\n        writes: this.writes\n      })\n    }));\n  }\n\n}","map":{"version":3,"sources":["/home/ana/Escritorio/EDUPLAN/telegram/proyecto-ana/proyecto/anny/node_modules/firebase-firestore-lite/dist/Transaction.js"],"names":["compileOptions","encode","fid","getPathFromRef","restrictTo","Document","Transaction","constructor","db","writes","preconditions","write","ref","data","options","Error","transforms","name","rootPath","precondition","doc","currentDocument","push","update","length","transform","document","fieldTransforms","get","refs","docs","batchGet","forEach","updateTime","__meta__","__missing__","exists","add","path","set","updateMask","delete","commit","fetch","endpoint","method","body","JSON","stringify"],"mappings":"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","sourcesContent":["import { compileOptions, encode, fid, getPathFromRef, restrictTo } from './utils';\nimport { Document } from './Document';\nexport class Transaction {\n    constructor(db) {\n        this.db = db;\n        this.writes = [];\n        this.preconditions = {};\n    }\n    /**\n     * Creates a write instruction and adds it into the\n     * transaction writes array.\n     * @private\n     */\n    write(ref, data, options = {}) {\n        if (typeof data !== 'object')\n            throw Error('The data argument is missing');\n        const transforms = [];\n        const name = `${this.db.rootPath}/${getPathFromRef(ref)}`;\n        const precondition = this.preconditions[name];\n        // Compile the JS Object into a Firebase Document.\n        const doc = encode(ref instanceof Document ? ref : data, transforms);\n        // Compile the options object into Firebase API arguments.\n        options = compileOptions(options, data);\n        // Check if there is any precondition created by getting a document\n        // as part of this transaction, and if there is then use it.\n        precondition && (options.currentDocument = precondition);\n        // Set the document's name\n        doc.name = name;\n        // Add the static properties.\n        this.writes.push({\n            update: doc,\n            ...options\n        });\n        // Add the Transforms if available.\n        transforms.length &&\n            this.writes.push({\n                transform: {\n                    document: doc.name,\n                    fieldTransforms: transforms\n                }\n            });\n    }\n    /**\n     * Wraps batch get with additional functionality needed in transactions.\n     * Transactions need to be atomic. So in order to know that the document\n     * wasn't changed concurrently then we save the updateTime of each document.\n     *\n     * Later we tell the database to use that as a precondition for the write.\n     * In other words, if the update time of a document changed, then abort\n     * the transaction. However, if a document didn't exist, then we use that\n     * as a precondition, telling the database that if it was created concurrently\n     * then it should abort the operation.\n     */\n    async get(refs) {\n        const docs = await this.db.batchGet(refs);\n        docs.forEach((doc) => {\n            const { name, updateTime } = doc.__meta__ || { name: doc.__missing__ };\n            this.preconditions[name] = updateTime\n                ? { updateTime }\n                : { exists: false };\n        });\n        return docs;\n    }\n    add(ref, data, options = {}) {\n        const path = `${restrictTo('col', ref)}/${fid()}`;\n        this.write(path, data, { exists: false, ...options });\n        return this.db.ref(path);\n    }\n    set(ref, data, options = {}) {\n        restrictTo('doc', ref);\n        this.write(ref, data, options);\n    }\n    update(ref, data, options = {}) {\n        restrictTo('doc', ref);\n        this.write(ref, data, { exists: true, updateMask: true, ...options });\n    }\n    /**\n     * Adds a delete operation to the transaction.\n     */\n    delete(ref, options = {}) {\n        const name = `${this.db.rootPath}/${restrictTo('doc', ref)}`;\n        options = compileOptions(options);\n        // Check if there is any precondition created by getting a document\n        // as part of this transaction, and if there is then use it.\n        this.preconditions[name] &&\n            (options.currentDocument = this.preconditions[name]);\n        this.writes.push({\n            delete: name,\n            ...options\n        });\n    }\n    /**\n     * Commits the transaction.\n     * Will throw if the transaction failed.\n     */\n    async commit() {\n        this.preconditions = {};\n        return void (await this.db.fetch(this.db.endpoint + ':commit', {\n            method: 'POST',\n            body: JSON.stringify({ writes: this.writes })\n        }));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}