{"ast":null,"code":"import { Document } from './Document';\n/**\n * Represents a collection list response, with functionality\n * for getting the next page when available.\n * @param {Object} rawList The response \"raw\" list object.\n * @param {Reference} ref A reference to the collection.\n * @param {Object} options Any options that were passed at first to the get request.\n */\n\nexport class List {\n  constructor(rawList, ref, options = {}) {\n    if (ref === undefined) throw Error('The \"reference\" argument is required when creating a List');\n    if (!ref.isCollection) throw Error('The reference in a list should point to a collection');\n    const {\n      documents,\n      nextPageToken\n    } = rawList;\n    this.ref = ref;\n    this.options = options;\n    this.documents = documents ? documents.map(rawDoc => new Document(rawDoc, ref.db)) : [];\n    this.options.pageToken = nextPageToken;\n  }\n  /** Fetches the next page in the query */\n\n\n  getNextPage() {\n    return this.ref.list(this.options);\n  }\n\n  [Symbol.iterator]() {\n    // Use a new index for each iterator. This makes multiple\n    // iterations over the iterable safe for non-trivial cases,\n    // such as use of break or nested looping over the same iterable.\n    let index = 0;\n    return {\n      next: () => {\n        if (index < this.documents.length) {\n          return {\n            value: this.documents[index++],\n            done: false\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  }\n\n}","map":{"version":3,"sources":["/home/ana/Escritorio/EDUPLAN/telegram/proyecto-ana/proyecto/anny/node_modules/firebase-firestore-lite/dist/List.js"],"names":["Document","List","constructor","rawList","ref","options","undefined","Error","isCollection","documents","nextPageToken","map","rawDoc","db","pageToken","getNextPage","list","Symbol","iterator","index","next","length","value","done"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,IAAN,CAAW;AACdC,EAAAA,WAAW,CAACC,OAAD,EAAUC,GAAV,EAAeC,OAAO,GAAG,EAAzB,EAA6B;AACpC,QAAID,GAAG,KAAKE,SAAZ,EACI,MAAMC,KAAK,CAAC,2DAAD,CAAX;AACJ,QAAI,CAACH,GAAG,CAACI,YAAT,EACI,MAAMD,KAAK,CAAC,sDAAD,CAAX;AACJ,UAAM;AAAEE,MAAAA,SAAF;AAAaC,MAAAA;AAAb,QAA+BP,OAArC;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKI,SAAL,GAAiBA,SAAS,GACpBA,SAAS,CAACE,GAAV,CAAcC,MAAM,IAAI,IAAIZ,QAAJ,CAAaY,MAAb,EAAqBR,GAAG,CAACS,EAAzB,CAAxB,CADoB,GAEpB,EAFN;AAGA,SAAKR,OAAL,CAAaS,SAAb,GAAyBJ,aAAzB;AACH;AACD;;;AACAK,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKX,GAAL,CAASY,IAAT,CAAc,KAAKX,OAAnB,CAAP;AACH;;AACe,GAAfY,MAAM,CAACC,QAAQ,IAAI;AAChB;AACA;AACA;AACA,QAAIC,KAAK,GAAG,CAAZ;AACA,WAAO;AACHC,MAAAA,IAAI,EAAE,MAAM;AACR,YAAID,KAAK,GAAG,KAAKV,SAAL,CAAeY,MAA3B,EAAmC;AAC/B,iBAAO;AAAEC,YAAAA,KAAK,EAAE,KAAKb,SAAL,CAAeU,KAAK,EAApB,CAAT;AAAkCI,YAAAA,IAAI,EAAE;AAAxC,WAAP;AACH,SAFD,MAGK;AACD,iBAAO;AAAEA,YAAAA,IAAI,EAAE;AAAR,WAAP;AACH;AACJ;AARE,KAAP;AAUH;;AAjCa","sourcesContent":["import { Document } from './Document';\n/**\n * Represents a collection list response, with functionality\n * for getting the next page when available.\n * @param {Object} rawList The response \"raw\" list object.\n * @param {Reference} ref A reference to the collection.\n * @param {Object} options Any options that were passed at first to the get request.\n */\nexport class List {\n    constructor(rawList, ref, options = {}) {\n        if (ref === undefined)\n            throw Error('The \"reference\" argument is required when creating a List');\n        if (!ref.isCollection)\n            throw Error('The reference in a list should point to a collection');\n        const { documents, nextPageToken } = rawList;\n        this.ref = ref;\n        this.options = options;\n        this.documents = documents\n            ? documents.map(rawDoc => new Document(rawDoc, ref.db))\n            : [];\n        this.options.pageToken = nextPageToken;\n    }\n    /** Fetches the next page in the query */\n    getNextPage() {\n        return this.ref.list(this.options);\n    }\n    [Symbol.iterator]() {\n        // Use a new index for each iterator. This makes multiple\n        // iterations over the iterable safe for non-trivial cases,\n        // such as use of break or nested looping over the same iterable.\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.documents.length) {\n                    return { value: this.documents[index++], done: false };\n                }\n                else {\n                    return { done: true };\n                }\n            }\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}