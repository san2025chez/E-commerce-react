{"ast":null,"code":"import { Reference } from './Reference';\nimport GeoPoint from './GeoPoint';\nimport Transform from './Transform';\nimport { Document } from './Document';\n/**\n * Used for generating random fids.\n * @private\n */\n\nconst validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';\n/**\n * Trims spaces and slashes from a path\n * @private\n */\n\nexport function trimPath(path) {\n  return path.trim().replace(/^\\/?/, '').replace(/\\/?$/, '');\n}\n/**\n * Returns true if a variable is a path that points to a collection\n * @private\n */\n\nexport function isPath(type, s) {\n  return typeof s === 'string' && s !== '' && trimPath(s).split('/').length % 2 === (type === 'doc' ? 0 : 1);\n}\n/**\n * Checks if a value is a Reference to a Document\n * @private\n */\n\nexport function isRef(type, val) {\n  return val instanceof Reference && (type === 'doc' ? !val.isCollection : val.isCollection);\n}\n/** @private */\n\nexport function isRefType(ref) {\n  return ref instanceof Reference || ref instanceof Document || typeof ref === 'string';\n}\n/** @private */\n\nexport function getPathFromRef(ref) {\n  var _a, _b, _c, _d;\n\n  if (!isRefType(ref)) throw TypeError('Expected a Reference, Document or a path but got something else');\n  return (_d = (_c = (_b = (_a = ref) === null || _a === void 0 ? void 0 : _a.__meta__) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ref.path) !== null && _d !== void 0 ? _d : trimPath(ref);\n}\n/** @private */\n\nexport function restrictTo(type, ref) {\n  const isDoc = type === 'doc';\n  const path = getPathFromRef(ref);\n  if (!isPath(type, path)) throw TypeError(`You are trying to access a method reserved for ${isDoc ? 'Documents' : 'Collections'} with a ${isDoc ? 'Collection' : 'Document'}`);\n  return path;\n}\n/**\n * Checks if a value is a number that is not negative and is an integer\n * @private\n */\n\nexport function isPositiveInteger(val) {\n  return Number.isInteger(val) && val >= 0;\n}\n/**\n * Converts an Object to a URI query String\n * @private\n */\n\nexport function objectToQuery(obj = {}, parentProp) {\n  const params = [];\n  const encode = encodeURIComponent;\n\n  for (const prop in obj) {\n    if (obj[prop] === undefined) continue; // Skip over undefined props.\n\n    const propPath = parentProp ? `${parentProp}.${prop}` : prop; // If it is an array then we should encode each value independently, and then join.\n\n    if (Array.isArray(obj[prop])) {\n      obj[prop].forEach(v => {\n        params.push(`${propPath}=${encode(v)}`);\n      });\n      continue;\n    }\n\n    if (typeof obj[prop] === 'object') {\n      const val = objectToQuery(obj[prop], propPath);\n      val && params.push(val);\n      continue;\n    }\n\n    params.push(`${propPath}=${encode(obj[prop])}`);\n  }\n\n  return (!parentProp && params.length ? '?' : '') + params.join('&');\n}\n/**\n * Returns an array of keyPaths of an object but skips over array's values\n * @private\n */\n\nexport function getKeyPaths(object, parentPath) {\n  let mask = [];\n\n  for (const key in object) {\n    if (object[key] instanceof Transform) continue;\n    const keyPath = parentPath ? `${parentPath}.${key}` : key; // Only check child props if the value is an object,\n    // but not null or arrays.\n\n    if (object[key] !== null && typeof object[key] === 'object' && !Array.isArray(object[key]) && !(object[key] instanceof Date)) {\n      mask = mask.concat(getKeyPaths(object[key], keyPath));\n      continue;\n    }\n\n    mask.push(keyPath);\n  }\n\n  return mask;\n}\n/**\n * Compile options object into firebase valid api arguments object\n * @private\n */\n\nexport function compileOptions(options, obj) {\n  const compiled = {};\n\n  for (let [key, value] of Object.entries(options)) {\n    if (value === undefined) continue;\n\n    switch (key) {\n      case 'exists':\n      case 'updateTime':\n        if (!compiled.currentDocument) compiled.currentDocument = {};\n        compiled.currentDocument[key] = value;\n        break;\n\n      case 'updateMask':\n        if (!obj) break;\n        if (value) compiled.updateMask = {\n          fieldPaths: getKeyPaths(obj)\n        };\n        break;\n\n      case 'mask':\n        compiled.mask = {\n          fieldPaths: value\n        };\n        break;\n\n      default:\n        compiled[key] = value;\n    }\n  }\n\n  return compiled;\n}\n/**\n * Decodes a Firebase Value into a JS one\n * @private\n */\n\nfunction decodeValue(value, db) {\n  // Get the value type.\n  const type = Object.keys(value)[0]; // Replace the firebase raw value, with actual value inside of it.\n\n  value = value[type]; // Some values need to be handled in a specific way,\n  // check if this is one of them, and return the value.\n\n  switch (type) {\n    case 'integerValue':\n      return Number(value);\n\n    case 'arrayValue':\n      return value.values ? value.values.map(val => decodeValue(val, db)) : [];\n\n    case 'mapValue':\n      return decode(value, db);\n\n    case 'timestampValue':\n      return new Date(value);\n\n    case 'referenceValue':\n      return new Reference(value.replace(db.rootPath, ''), db);\n\n    case 'geoPointValue':\n      return new GeoPoint(value.latitude, value.longitude);\n    // These are the rest of the values.\n    // We include all of them instead of using 'default:'\n    // because we use it as validation.\n\n    case 'stringValue':\n    case 'doubleValue':\n    case 'booleanValue':\n    case 'nullValue':\n    case 'bytesValue':\n      return value;\n  } // If none matched throw.\n\n\n  throw Error(`Invalid Firestore value_type \"${type}\"`);\n}\n/**\n * Decodes a Firebase map into a JS object\n * @private\n */\n\n\nexport function decode(map, db) {\n  if (db === undefined) throw Error('Argument \"db\" is required but missing');\n  const object = {};\n\n  for (const key in map.fields) {\n    object[key] = decodeValue(map.fields[key], db);\n  }\n\n  return object;\n}\n/**\n * Encodes a JS variable into a Firebase Value\n * @private\n */\n\nexport function encodeValue(value, transforms, parentPath) {\n  const objectClass = Object.prototype.toString.call(value);\n  let valueType = objectClass.substring(8, objectClass.length - 1).toLowerCase() + 'Value';\n\n  switch (valueType) {\n    case 'numberValue':\n      valueType = Number.isInteger(value) ? 'integerValue' : 'doubleValue';\n      value = valueType === 'integerValue' ? String(value) : value;\n      break;\n\n    case 'arrayValue':\n      value = value.length ? {\n        values: value.map(encodeValue)\n      } : {};\n      break;\n\n    case 'dateValue':\n      valueType = 'timestampValue';\n      value = value.toISOString();\n      break;\n\n    case 'objectValue':\n      // If the object is a custom type, then use its built in encoder\n      // and return it.\n      if (value instanceof Reference || value instanceof GeoPoint) return value.toJSON(); // Else assume its intended to be a Map value.\n\n      valueType = 'mapValue';\n      value = encode(value, transforms, parentPath);\n      break;\n  }\n\n  return {\n    [valueType]: value\n  };\n}\n/**\n * Converts a Javascript object into a write instruction\n * @private\n */\n\nexport function encode(object, transforms, parentPath) {\n  const keys = Object.keys(object);\n  if (keys.length === 0) return {};\n  const map = {\n    fields: {}\n  };\n\n  for (const key of keys) {\n    if (object[key] === undefined) continue;\n    const value = object[key];\n    const path = parentPath ? `${parentPath}.${key}` : key; // If this is a transform then add it to the transforms\n    // list and skip its parsing. but only if a transforms array\n    // was provided.\n\n    if (value instanceof Transform) {\n      value.fieldPath = path;\n      transforms && transforms.push(value);\n      continue;\n    }\n\n    map.fields[key] = encodeValue(value, transforms, path);\n  }\n\n  return map;\n}\n/**\n * Generates 22 chars long random alphanumerics unique identifiers\n * @private\n */\n\nexport function fid() {\n  const randBytes = crypto.getRandomValues(new Uint8Array(20));\n  return Array.from(randBytes).map(b => validChars[b % 63]).join('');\n}","map":{"version":3,"sources":["/home/ana/Escritorio/EDUPLAN/telegram/proyecto-ana/proyecto/anny/node_modules/firebase-firestore-lite/dist/utils.js"],"names":["Reference","GeoPoint","Transform","Document","validChars","trimPath","path","trim","replace","isPath","type","s","split","length","isRef","val","isCollection","isRefType","ref","getPathFromRef","_a","_b","_c","_d","TypeError","__meta__","restrictTo","isDoc","isPositiveInteger","Number","isInteger","objectToQuery","obj","parentProp","params","encode","encodeURIComponent","prop","undefined","propPath","Array","isArray","forEach","v","push","join","getKeyPaths","object","parentPath","mask","key","keyPath","Date","concat","compileOptions","options","compiled","value","Object","entries","currentDocument","updateMask","fieldPaths","decodeValue","db","keys","values","map","decode","rootPath","latitude","longitude","Error","fields","encodeValue","transforms","objectClass","prototype","toString","call","valueType","substring","toLowerCase","String","toISOString","toJSON","fieldPath","fid","randBytes","crypto","getRandomValues","Uint8Array","from","b"],"mappings":"AAAA,SAASA,SAAT,QAA0B,aAA1B;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA;AACA;AACA;AACA;;AACA,MAAMC,UAAU,GAAG,iEAAnB;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AAC3B,SAAOA,IAAI,CAACC,IAAL,GAAYC,OAAZ,CAAoB,MAApB,EAA4B,EAA5B,EAAgCA,OAAhC,CAAwC,MAAxC,EAAgD,EAAhD,CAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASC,MAAT,CAAgBC,IAAhB,EAAsBC,CAAtB,EAAyB;AAC5B,SAAQ,OAAOA,CAAP,KAAa,QAAb,IACJA,CAAC,KAAK,EADF,IAEJN,QAAQ,CAACM,CAAD,CAAR,CAAYC,KAAZ,CAAkB,GAAlB,EAAuBC,MAAvB,GAAgC,CAAhC,MAAuCH,IAAI,KAAK,KAAT,GAAiB,CAAjB,GAAqB,CAA5D,CAFJ;AAGH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASI,KAAT,CAAeJ,IAAf,EAAqBK,GAArB,EAA0B;AAC7B,SAAQA,GAAG,YAAYf,SAAf,KACHU,IAAI,KAAK,KAAT,GAAiB,CAACK,GAAG,CAACC,YAAtB,GAAqCD,GAAG,CAACC,YADtC,CAAR;AAEH;AACD;;AACA,OAAO,SAASC,SAAT,CAAmBC,GAAnB,EAAwB;AAC3B,SAAQA,GAAG,YAAYlB,SAAf,IACJkB,GAAG,YAAYf,QADX,IAEJ,OAAOe,GAAP,KAAe,QAFnB;AAGH;AACD;;AACA,OAAO,SAASC,cAAT,CAAwBD,GAAxB,EAA6B;AAChC,MAAIE,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;AACA,MAAI,CAACN,SAAS,CAACC,GAAD,CAAd,EACI,MAAMM,SAAS,CAAC,iEAAD,CAAf;AACJ,SAAQ,CAACD,EAAE,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAGF,GAAN,MAAe,IAAf,IAAuBE,EAAE,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,EAAE,CAACK,QAAzD,MAAuE,IAAvE,IAA+EJ,EAAE,KAAK,KAAK,CAA3F,GAA+F,KAAK,CAApG,GAAwGA,EAAE,CAACf,IAAjH,MAA2H,IAA3H,IAAmIgB,EAAE,KAAK,KAAK,CAA/I,GAAmJA,EAAnJ,GAAwJJ,GAAG,CAACZ,IAAlK,MAA4K,IAA5K,IAAoLiB,EAAE,KAAK,KAAK,CAAhM,GAAoMA,EAApM,GAAyMlB,QAAQ,CAACa,GAAD,CAAzN;AACH;AACD;;AACA,OAAO,SAASQ,UAAT,CAAoBhB,IAApB,EAA0BQ,GAA1B,EAA+B;AAClC,QAAMS,KAAK,GAAGjB,IAAI,KAAK,KAAvB;AACA,QAAMJ,IAAI,GAAGa,cAAc,CAACD,GAAD,CAA3B;AACA,MAAI,CAACT,MAAM,CAACC,IAAD,EAAOJ,IAAP,CAAX,EACI,MAAMkB,SAAS,CAAE,kDAAiDG,KAAK,GAAG,WAAH,GAAiB,aAAc,WAAUA,KAAK,GAAG,YAAH,GAAkB,UAAW,EAAnI,CAAf;AACJ,SAAOrB,IAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASsB,iBAAT,CAA2Bb,GAA3B,EAAgC;AACnC,SAAOc,MAAM,CAACC,SAAP,CAAiBf,GAAjB,KAAyBA,GAAG,IAAI,CAAvC;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASgB,aAAT,CAAuBC,GAAG,GAAG,EAA7B,EAAiCC,UAAjC,EAA6C;AAChD,QAAMC,MAAM,GAAG,EAAf;AACA,QAAMC,MAAM,GAAGC,kBAAf;;AACA,OAAK,MAAMC,IAAX,IAAmBL,GAAnB,EAAwB;AACpB,QAAIA,GAAG,CAACK,IAAD,CAAH,KAAcC,SAAlB,EACI,SAFgB,CAEN;;AACd,UAAMC,QAAQ,GAAGN,UAAU,GAAI,GAAEA,UAAW,IAAGI,IAAK,EAAzB,GAA6BA,IAAxD,CAHoB,CAIpB;;AACA,QAAIG,KAAK,CAACC,OAAN,CAAcT,GAAG,CAACK,IAAD,CAAjB,CAAJ,EAA8B;AAC1BL,MAAAA,GAAG,CAACK,IAAD,CAAH,CAAUK,OAAV,CAAmBC,CAAD,IAAO;AACrBT,QAAAA,MAAM,CAACU,IAAP,CAAa,GAAEL,QAAS,IAAGJ,MAAM,CAACQ,CAAD,CAAI,EAArC;AACH,OAFD;AAGA;AACH;;AACD,QAAI,OAAOX,GAAG,CAACK,IAAD,CAAV,KAAqB,QAAzB,EAAmC;AAC/B,YAAMtB,GAAG,GAAGgB,aAAa,CAACC,GAAG,CAACK,IAAD,CAAJ,EAAYE,QAAZ,CAAzB;AACAxB,MAAAA,GAAG,IAAImB,MAAM,CAACU,IAAP,CAAY7B,GAAZ,CAAP;AACA;AACH;;AACDmB,IAAAA,MAAM,CAACU,IAAP,CAAa,GAAEL,QAAS,IAAGJ,MAAM,CAACH,GAAG,CAACK,IAAD,CAAJ,CAAY,EAA7C;AACH;;AACD,SAAO,CAAC,CAACJ,UAAD,IAAeC,MAAM,CAACrB,MAAtB,GAA+B,GAA/B,GAAqC,EAAtC,IAA4CqB,MAAM,CAACW,IAAP,CAAY,GAAZ,CAAnD;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,UAA7B,EAAyC;AAC5C,MAAIC,IAAI,GAAG,EAAX;;AACA,OAAK,MAAMC,GAAX,IAAkBH,MAAlB,EAA0B;AACtB,QAAIA,MAAM,CAACG,GAAD,CAAN,YAAuBhD,SAA3B,EACI;AACJ,UAAMiD,OAAO,GAAGH,UAAU,GAAI,GAAEA,UAAW,IAAGE,GAAI,EAAxB,GAA4BA,GAAtD,CAHsB,CAItB;AACA;;AACA,QAAIH,MAAM,CAACG,GAAD,CAAN,KAAgB,IAAhB,IACA,OAAOH,MAAM,CAACG,GAAD,CAAb,KAAuB,QADvB,IAEA,CAACV,KAAK,CAACC,OAAN,CAAcM,MAAM,CAACG,GAAD,CAApB,CAFD,IAGA,EAAEH,MAAM,CAACG,GAAD,CAAN,YAAuBE,IAAzB,CAHJ,EAGoC;AAChCH,MAAAA,IAAI,GAAGA,IAAI,CAACI,MAAL,CAAYP,WAAW,CAACC,MAAM,CAACG,GAAD,CAAP,EAAcC,OAAd,CAAvB,CAAP;AACA;AACH;;AACDF,IAAAA,IAAI,CAACL,IAAL,CAAUO,OAAV;AACH;;AACD,SAAOF,IAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASK,cAAT,CAAwBC,OAAxB,EAAiCvB,GAAjC,EAAsC;AACzC,QAAMwB,QAAQ,GAAG,EAAjB;;AACA,OAAK,IAAI,CAACN,GAAD,EAAMO,KAAN,CAAT,IAAyBC,MAAM,CAACC,OAAP,CAAeJ,OAAf,CAAzB,EAAkD;AAC9C,QAAIE,KAAK,KAAKnB,SAAd,EACI;;AACJ,YAAQY,GAAR;AACI,WAAK,QAAL;AACA,WAAK,YAAL;AACI,YAAI,CAACM,QAAQ,CAACI,eAAd,EACIJ,QAAQ,CAACI,eAAT,GAA2B,EAA3B;AACJJ,QAAAA,QAAQ,CAACI,eAAT,CAAyBV,GAAzB,IAAgCO,KAAhC;AACA;;AACJ,WAAK,YAAL;AACI,YAAI,CAACzB,GAAL,EACI;AACJ,YAAIyB,KAAJ,EACID,QAAQ,CAACK,UAAT,GAAsB;AAAEC,UAAAA,UAAU,EAAEhB,WAAW,CAACd,GAAD;AAAzB,SAAtB;AACJ;;AACJ,WAAK,MAAL;AACIwB,QAAAA,QAAQ,CAACP,IAAT,GAAgB;AAAEa,UAAAA,UAAU,EAAEL;AAAd,SAAhB;AACA;;AACJ;AACID,QAAAA,QAAQ,CAACN,GAAD,CAAR,GAAgBO,KAAhB;AAjBR;AAmBH;;AACD,SAAOD,QAAP;AACH;AACD;AACA;AACA;AACA;;AACA,SAASO,WAAT,CAAqBN,KAArB,EAA4BO,EAA5B,EAAgC;AAC5B;AACA,QAAMtD,IAAI,GAAGgD,MAAM,CAACO,IAAP,CAAYR,KAAZ,EAAmB,CAAnB,CAAb,CAF4B,CAG5B;;AACAA,EAAAA,KAAK,GAAGA,KAAK,CAAC/C,IAAD,CAAb,CAJ4B,CAK5B;AACA;;AACA,UAAQA,IAAR;AACI,SAAK,cAAL;AACI,aAAOmB,MAAM,CAAC4B,KAAD,CAAb;;AACJ,SAAK,YAAL;AACI,aAAOA,KAAK,CAACS,MAAN,GACDT,KAAK,CAACS,MAAN,CAAaC,GAAb,CAAkBpD,GAAD,IAASgD,WAAW,CAAChD,GAAD,EAAMiD,EAAN,CAArC,CADC,GAED,EAFN;;AAGJ,SAAK,UAAL;AACI,aAAOI,MAAM,CAACX,KAAD,EAAQO,EAAR,CAAb;;AACJ,SAAK,gBAAL;AACI,aAAO,IAAIZ,IAAJ,CAASK,KAAT,CAAP;;AACJ,SAAK,gBAAL;AACI,aAAO,IAAIzD,SAAJ,CAAcyD,KAAK,CAACjD,OAAN,CAAcwD,EAAE,CAACK,QAAjB,EAA2B,EAA3B,CAAd,EAA8CL,EAA9C,CAAP;;AACJ,SAAK,eAAL;AACI,aAAO,IAAI/D,QAAJ,CAAawD,KAAK,CAACa,QAAnB,EAA6Bb,KAAK,CAACc,SAAnC,CAAP;AACJ;AACA;AACA;;AACA,SAAK,aAAL;AACA,SAAK,aAAL;AACA,SAAK,cAAL;AACA,SAAK,WAAL;AACA,SAAK,YAAL;AACI,aAAOd,KAAP;AAvBR,GAP4B,CAgC5B;;;AACA,QAAMe,KAAK,CAAE,iCAAgC9D,IAAK,GAAvC,CAAX;AACH;AACD;AACA;AACA;AACA;;;AACA,OAAO,SAAS0D,MAAT,CAAgBD,GAAhB,EAAqBH,EAArB,EAAyB;AAC5B,MAAIA,EAAE,KAAK1B,SAAX,EACI,MAAMkC,KAAK,CAAC,uCAAD,CAAX;AACJ,QAAMzB,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMG,GAAX,IAAkBiB,GAAG,CAACM,MAAtB,EAA8B;AAC1B1B,IAAAA,MAAM,CAACG,GAAD,CAAN,GAAca,WAAW,CAACI,GAAG,CAACM,MAAJ,CAAWvB,GAAX,CAAD,EAAkBc,EAAlB,CAAzB;AACH;;AACD,SAAOjB,MAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAAS2B,WAAT,CAAqBjB,KAArB,EAA4BkB,UAA5B,EAAwC3B,UAAxC,EAAoD;AACvD,QAAM4B,WAAW,GAAGlB,MAAM,CAACmB,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BtB,KAA/B,CAApB;AACA,MAAIuB,SAAS,GAAGJ,WAAW,CAACK,SAAZ,CAAsB,CAAtB,EAAyBL,WAAW,CAAC/D,MAAZ,GAAqB,CAA9C,EAAiDqE,WAAjD,KAAiE,OAAjF;;AACA,UAAQF,SAAR;AACI,SAAK,aAAL;AACIA,MAAAA,SAAS,GAAGnD,MAAM,CAACC,SAAP,CAAiB2B,KAAjB,IAA0B,cAA1B,GAA2C,aAAvD;AACAA,MAAAA,KAAK,GAAGuB,SAAS,KAAK,cAAd,GAA+BG,MAAM,CAAC1B,KAAD,CAArC,GAA+CA,KAAvD;AACA;;AACJ,SAAK,YAAL;AACIA,MAAAA,KAAK,GAAGA,KAAK,CAAC5C,MAAN,GAAe;AAAEqD,QAAAA,MAAM,EAAET,KAAK,CAACU,GAAN,CAAUO,WAAV;AAAV,OAAf,GAAoD,EAA5D;AACA;;AACJ,SAAK,WAAL;AACIM,MAAAA,SAAS,GAAG,gBAAZ;AACAvB,MAAAA,KAAK,GAAGA,KAAK,CAAC2B,WAAN,EAAR;AACA;;AACJ,SAAK,aAAL;AACI;AACA;AACA,UAAI3B,KAAK,YAAYzD,SAAjB,IAA8ByD,KAAK,YAAYxD,QAAnD,EACI,OAAOwD,KAAK,CAAC4B,MAAN,EAAP,CAJR,CAKI;;AACAL,MAAAA,SAAS,GAAG,UAAZ;AACAvB,MAAAA,KAAK,GAAGtB,MAAM,CAACsB,KAAD,EAAQkB,UAAR,EAAoB3B,UAApB,CAAd;AACA;AApBR;;AAsBA,SAAO;AAAE,KAACgC,SAAD,GAAavB;AAAf,GAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAAStB,MAAT,CAAgBY,MAAhB,EAAwB4B,UAAxB,EAAoC3B,UAApC,EAAgD;AACnD,QAAMiB,IAAI,GAAGP,MAAM,CAACO,IAAP,CAAYlB,MAAZ,CAAb;AACA,MAAIkB,IAAI,CAACpD,MAAL,KAAgB,CAApB,EACI,OAAO,EAAP;AACJ,QAAMsD,GAAG,GAAG;AAAEM,IAAAA,MAAM,EAAE;AAAV,GAAZ;;AACA,OAAK,MAAMvB,GAAX,IAAkBe,IAAlB,EAAwB;AACpB,QAAIlB,MAAM,CAACG,GAAD,CAAN,KAAgBZ,SAApB,EACI;AACJ,UAAMmB,KAAK,GAAGV,MAAM,CAACG,GAAD,CAApB;AACA,UAAM5C,IAAI,GAAG0C,UAAU,GAAI,GAAEA,UAAW,IAAGE,GAAI,EAAxB,GAA4BA,GAAnD,CAJoB,CAKpB;AACA;AACA;;AACA,QAAIO,KAAK,YAAYvD,SAArB,EAAgC;AAC5BuD,MAAAA,KAAK,CAAC6B,SAAN,GAAkBhF,IAAlB;AACAqE,MAAAA,UAAU,IAAIA,UAAU,CAAC/B,IAAX,CAAgBa,KAAhB,CAAd;AACA;AACH;;AACDU,IAAAA,GAAG,CAACM,MAAJ,CAAWvB,GAAX,IAAkBwB,WAAW,CAACjB,KAAD,EAAQkB,UAAR,EAAoBrE,IAApB,CAA7B;AACH;;AACD,SAAO6D,GAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASoB,GAAT,GAAe;AAClB,QAAMC,SAAS,GAAGC,MAAM,CAACC,eAAP,CAAuB,IAAIC,UAAJ,CAAe,EAAf,CAAvB,CAAlB;AACA,SAAOnD,KAAK,CAACoD,IAAN,CAAWJ,SAAX,EACFrB,GADE,CACE0B,CAAC,IAAIzF,UAAU,CAACyF,CAAC,GAAG,EAAL,CADjB,EAEFhD,IAFE,CAEG,EAFH,CAAP;AAGH","sourcesContent":["import { Reference } from './Reference';\nimport GeoPoint from './GeoPoint';\nimport Transform from './Transform';\nimport { Document } from './Document';\n/**\n * Used for generating random fids.\n * @private\n */\nconst validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';\n/**\n * Trims spaces and slashes from a path\n * @private\n */\nexport function trimPath(path) {\n    return path.trim().replace(/^\\/?/, '').replace(/\\/?$/, '');\n}\n/**\n * Returns true if a variable is a path that points to a collection\n * @private\n */\nexport function isPath(type, s) {\n    return (typeof s === 'string' &&\n        s !== '' &&\n        trimPath(s).split('/').length % 2 === (type === 'doc' ? 0 : 1));\n}\n/**\n * Checks if a value is a Reference to a Document\n * @private\n */\nexport function isRef(type, val) {\n    return (val instanceof Reference &&\n        (type === 'doc' ? !val.isCollection : val.isCollection));\n}\n/** @private */\nexport function isRefType(ref) {\n    return (ref instanceof Reference ||\n        ref instanceof Document ||\n        typeof ref === 'string');\n}\n/** @private */\nexport function getPathFromRef(ref) {\n    var _a, _b, _c, _d;\n    if (!isRefType(ref))\n        throw TypeError('Expected a Reference, Document or a path but got something else');\n    return ((_d = (_c = (_b = (_a = ref) === null || _a === void 0 ? void 0 : _a.__meta__) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : ref.path) !== null && _d !== void 0 ? _d : trimPath(ref));\n}\n/** @private */\nexport function restrictTo(type, ref) {\n    const isDoc = type === 'doc';\n    const path = getPathFromRef(ref);\n    if (!isPath(type, path))\n        throw TypeError(`You are trying to access a method reserved for ${isDoc ? 'Documents' : 'Collections'} with a ${isDoc ? 'Collection' : 'Document'}`);\n    return path;\n}\n/**\n * Checks if a value is a number that is not negative and is an integer\n * @private\n */\nexport function isPositiveInteger(val) {\n    return Number.isInteger(val) && val >= 0;\n}\n/**\n * Converts an Object to a URI query String\n * @private\n */\nexport function objectToQuery(obj = {}, parentProp) {\n    const params = [];\n    const encode = encodeURIComponent;\n    for (const prop in obj) {\n        if (obj[prop] === undefined)\n            continue; // Skip over undefined props.\n        const propPath = parentProp ? `${parentProp}.${prop}` : prop;\n        // If it is an array then we should encode each value independently, and then join.\n        if (Array.isArray(obj[prop])) {\n            obj[prop].forEach((v) => {\n                params.push(`${propPath}=${encode(v)}`);\n            });\n            continue;\n        }\n        if (typeof obj[prop] === 'object') {\n            const val = objectToQuery(obj[prop], propPath);\n            val && params.push(val);\n            continue;\n        }\n        params.push(`${propPath}=${encode(obj[prop])}`);\n    }\n    return (!parentProp && params.length ? '?' : '') + params.join('&');\n}\n/**\n * Returns an array of keyPaths of an object but skips over array's values\n * @private\n */\nexport function getKeyPaths(object, parentPath) {\n    let mask = [];\n    for (const key in object) {\n        if (object[key] instanceof Transform)\n            continue;\n        const keyPath = parentPath ? `${parentPath}.${key}` : key;\n        // Only check child props if the value is an object,\n        // but not null or arrays.\n        if (object[key] !== null &&\n            typeof object[key] === 'object' &&\n            !Array.isArray(object[key]) &&\n            !(object[key] instanceof Date)) {\n            mask = mask.concat(getKeyPaths(object[key], keyPath));\n            continue;\n        }\n        mask.push(keyPath);\n    }\n    return mask;\n}\n/**\n * Compile options object into firebase valid api arguments object\n * @private\n */\nexport function compileOptions(options, obj) {\n    const compiled = {};\n    for (let [key, value] of Object.entries(options)) {\n        if (value === undefined)\n            continue;\n        switch (key) {\n            case 'exists':\n            case 'updateTime':\n                if (!compiled.currentDocument)\n                    compiled.currentDocument = {};\n                compiled.currentDocument[key] = value;\n                break;\n            case 'updateMask':\n                if (!obj)\n                    break;\n                if (value)\n                    compiled.updateMask = { fieldPaths: getKeyPaths(obj) };\n                break;\n            case 'mask':\n                compiled.mask = { fieldPaths: value };\n                break;\n            default:\n                compiled[key] = value;\n        }\n    }\n    return compiled;\n}\n/**\n * Decodes a Firebase Value into a JS one\n * @private\n */\nfunction decodeValue(value, db) {\n    // Get the value type.\n    const type = Object.keys(value)[0];\n    // Replace the firebase raw value, with actual value inside of it.\n    value = value[type];\n    // Some values need to be handled in a specific way,\n    // check if this is one of them, and return the value.\n    switch (type) {\n        case 'integerValue':\n            return Number(value);\n        case 'arrayValue':\n            return value.values\n                ? value.values.map((val) => decodeValue(val, db))\n                : [];\n        case 'mapValue':\n            return decode(value, db);\n        case 'timestampValue':\n            return new Date(value);\n        case 'referenceValue':\n            return new Reference(value.replace(db.rootPath, ''), db);\n        case 'geoPointValue':\n            return new GeoPoint(value.latitude, value.longitude);\n        // These are the rest of the values.\n        // We include all of them instead of using 'default:'\n        // because we use it as validation.\n        case 'stringValue':\n        case 'doubleValue':\n        case 'booleanValue':\n        case 'nullValue':\n        case 'bytesValue':\n            return value;\n    }\n    // If none matched throw.\n    throw Error(`Invalid Firestore value_type \"${type}\"`);\n}\n/**\n * Decodes a Firebase map into a JS object\n * @private\n */\nexport function decode(map, db) {\n    if (db === undefined)\n        throw Error('Argument \"db\" is required but missing');\n    const object = {};\n    for (const key in map.fields) {\n        object[key] = decodeValue(map.fields[key], db);\n    }\n    return object;\n}\n/**\n * Encodes a JS variable into a Firebase Value\n * @private\n */\nexport function encodeValue(value, transforms, parentPath) {\n    const objectClass = Object.prototype.toString.call(value);\n    let valueType = objectClass.substring(8, objectClass.length - 1).toLowerCase() + 'Value';\n    switch (valueType) {\n        case 'numberValue':\n            valueType = Number.isInteger(value) ? 'integerValue' : 'doubleValue';\n            value = valueType === 'integerValue' ? String(value) : value;\n            break;\n        case 'arrayValue':\n            value = value.length ? { values: value.map(encodeValue) } : {};\n            break;\n        case 'dateValue':\n            valueType = 'timestampValue';\n            value = value.toISOString();\n            break;\n        case 'objectValue':\n            // If the object is a custom type, then use its built in encoder\n            // and return it.\n            if (value instanceof Reference || value instanceof GeoPoint)\n                return value.toJSON();\n            // Else assume its intended to be a Map value.\n            valueType = 'mapValue';\n            value = encode(value, transforms, parentPath);\n            break;\n    }\n    return { [valueType]: value };\n}\n/**\n * Converts a Javascript object into a write instruction\n * @private\n */\nexport function encode(object, transforms, parentPath) {\n    const keys = Object.keys(object);\n    if (keys.length === 0)\n        return {};\n    const map = { fields: {} };\n    for (const key of keys) {\n        if (object[key] === undefined)\n            continue;\n        const value = object[key];\n        const path = parentPath ? `${parentPath}.${key}` : key;\n        // If this is a transform then add it to the transforms\n        // list and skip its parsing. but only if a transforms array\n        // was provided.\n        if (value instanceof Transform) {\n            value.fieldPath = path;\n            transforms && transforms.push(value);\n            continue;\n        }\n        map.fields[key] = encodeValue(value, transforms, path);\n    }\n    return map;\n}\n/**\n * Generates 22 chars long random alphanumerics unique identifiers\n * @private\n */\nexport function fid() {\n    const randBytes = crypto.getRandomValues(new Uint8Array(20));\n    return Array.from(randBytes)\n        .map(b => validChars[b % 63])\n        .join('');\n}\n"]},"metadata":{},"sourceType":"module"}