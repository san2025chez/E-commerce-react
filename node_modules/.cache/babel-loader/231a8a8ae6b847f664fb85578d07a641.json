{"ast":null,"code":"import { Reference } from './Reference';\nimport { Document } from './Document';\nimport { restrictTo } from './utils';\nimport { Transaction } from './Transaction';\nimport { Query } from './Query';\n/** @private */\n\nasync function handleApiResponse(res) {\n  if (!res.ok) {\n    const data = await res.json();\n    if (Array.isArray(data)) throw data.length === 1 ? Object.assign(new Error(), data[0].error) : data;\n    throw Object.assign(new Error(), data.error);\n  }\n\n  return res.json();\n}\n/** Database Instance */\n\n\nexport class Database {\n  constructor({\n    projectId,\n    auth,\n    name = '(default)',\n    host = 'firestore.googleapis.com',\n    ssl = true\n  }) {\n    if (projectId === undefined) throw Error('Database constructor expected the \"config\" argument to have a valid \"projectId\" property');\n    this.name = name;\n    this.auth = auth;\n    this.rootPath = `projects/${projectId}/databases/${name}/documents`;\n    this.endpoint = `http${ssl ? 's' : ''}://${host}/v1/${this.rootPath}`;\n  }\n  /**\n   * For internal use only.\n   * Uses native fetch, but adds authorization headers\n   * if the Reference was instantiated with an auth instance.\n   * The API is exactly the same as native fetch.\n   * @private\n   */\n\n\n  fetch(input, init) {\n    if (this.auth && this.auth.authorizedRequest) return this.auth.authorizedRequest(input, init).then(handleApiResponse);\n    return fetch(input, init).then(handleApiResponse);\n  }\n  /**\n   * Returns a reference to a document or a collection.\n   * @param {(string|Document)} path Path to the collection or document.\n   * @returns {Reference} instance of a reference.\n   */\n\n\n  ref(path) {\n    if (path instanceof Document) path = path.__meta__.path;\n    return new Reference(path, this);\n  }\n\n  async batchGet(refs) {\n    const response = await this.fetch(this.endpoint + ':batchGet', {\n      method: 'POST',\n      body: JSON.stringify({\n        documents: refs.map(ref => {\n          const path = restrictTo('doc', ref);\n          return `${this.rootPath}/${path}`;\n        })\n      })\n    });\n    return response.map(entry => entry.found ? new Document(entry.found, this) : Object.defineProperty({}, '__missing__', {\n      value: entry.missing\n    }));\n  }\n  /** Returns a new transaction instance */\n\n\n  transaction() {\n    return new Transaction(this);\n  }\n  /**\n   * Executes the given `updateFunction` and attempts to commit\n   * the changes applied within it as a Transaction. If any document\n   * read within the transaction has changed, Cloud Firestore retries\n   * the updateFunction. If it fails to commit after 5 attempts, the\n   * transaction fails and throws.\n   *\n   * Will not re-attempt if an error is thrown inside the `updateFunction`\n   * or if any error that is not related to the transaction is received\n   * like a network error etc.\n   */\n\n\n  async runTransaction(fn, attempts = 5) {\n    const tx = new Transaction(this);\n\n    while (attempts > 0) {\n      await fn(tx); // Only retry on transaction errors.\n\n      try {\n        await tx.commit();\n        break; // Stop trying if it succeeded.\n      } catch (e) {\n        // Only throw if the error is not related to the transaction, or it is the last attempt.\n        if (attempts === 0 || e.status !== 'NOT_FOUND' && e.status !== 'FAILED_PRECONDITION') throw Error(e);\n      }\n\n      attempts--;\n    }\n  }\n  /**\n   * Query all all collections that match the given name that\n   * also are descendants of a given document (or root by default).\n   */\n\n\n  collectionGroup(collectionId, options = {}) {\n    return new Query(this.ref('parent' in options ? options.parent : ''), {\n      from: {\n        collectionId,\n        allDescendants: true\n      },\n      ...options\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/ana/Escritorio/EDUPLAN/telegram/proyecto-ana/proyecto/anny/node_modules/firebase-firestore-lite/dist/Database.js"],"names":["Reference","Document","restrictTo","Transaction","Query","handleApiResponse","res","ok","data","json","Array","isArray","length","Object","assign","Error","error","Database","constructor","projectId","auth","name","host","ssl","undefined","rootPath","endpoint","fetch","input","init","authorizedRequest","then","ref","path","__meta__","batchGet","refs","response","method","body","JSON","stringify","documents","map","entry","found","defineProperty","value","missing","transaction","runTransaction","fn","attempts","tx","commit","e","status","collectionGroup","collectionId","options","parent","from","allDescendants"],"mappings":"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","sourcesContent":["import { Reference } from './Reference';\nimport { Document } from './Document';\nimport { restrictTo } from './utils';\nimport { Transaction } from './Transaction';\nimport { Query } from './Query';\n/** @private */\nasync function handleApiResponse(res) {\n    if (!res.ok) {\n        const data = await res.json();\n        if (Array.isArray(data))\n            throw data.length === 1\n                ? Object.assign(new Error(), data[0].error)\n                : data;\n        throw Object.assign(new Error(), data.error);\n    }\n    return res.json();\n}\n/** Database Instance */\nexport class Database {\n    constructor({ projectId, auth, name = '(default)', host = 'firestore.googleapis.com', ssl = true }) {\n        if (projectId === undefined)\n            throw Error('Database constructor expected the \"config\" argument to have a valid \"projectId\" property');\n        this.name = name;\n        this.auth = auth;\n        this.rootPath = `projects/${projectId}/databases/${name}/documents`;\n        this.endpoint = `http${ssl ? 's' : ''}://${host}/v1/${this.rootPath}`;\n    }\n    /**\n     * For internal use only.\n     * Uses native fetch, but adds authorization headers\n     * if the Reference was instantiated with an auth instance.\n     * The API is exactly the same as native fetch.\n     * @private\n     */\n    fetch(input, init) {\n        if (this.auth && this.auth.authorizedRequest)\n            return this.auth.authorizedRequest(input, init).then(handleApiResponse);\n        return fetch(input, init).then(handleApiResponse);\n    }\n    /**\n     * Returns a reference to a document or a collection.\n     * @param {(string|Document)} path Path to the collection or document.\n     * @returns {Reference} instance of a reference.\n     */\n    ref(path) {\n        if (path instanceof Document)\n            path = path.__meta__.path;\n        return new Reference(path, this);\n    }\n    async batchGet(refs) {\n        const response = await this.fetch(this.endpoint + ':batchGet', {\n            method: 'POST',\n            body: JSON.stringify({\n                documents: refs.map(ref => {\n                    const path = restrictTo('doc', ref);\n                    return `${this.rootPath}/${path}`;\n                })\n            })\n        });\n        return response.map((entry) => entry.found\n            ? new Document(entry.found, this)\n            : Object.defineProperty({}, '__missing__', { value: entry.missing }));\n    }\n    /** Returns a new transaction instance */\n    transaction() {\n        return new Transaction(this);\n    }\n    /**\n     * Executes the given `updateFunction` and attempts to commit\n     * the changes applied within it as a Transaction. If any document\n     * read within the transaction has changed, Cloud Firestore retries\n     * the updateFunction. If it fails to commit after 5 attempts, the\n     * transaction fails and throws.\n     *\n     * Will not re-attempt if an error is thrown inside the `updateFunction`\n     * or if any error that is not related to the transaction is received\n     * like a network error etc.\n     */\n    async runTransaction(fn, attempts = 5) {\n        const tx = new Transaction(this);\n        while (attempts > 0) {\n            await fn(tx);\n            // Only retry on transaction errors.\n            try {\n                await tx.commit();\n                break; // Stop trying if it succeeded.\n            }\n            catch (e) {\n                // Only throw if the error is not related to the transaction, or it is the last attempt.\n                if (attempts === 0 ||\n                    (e.status !== 'NOT_FOUND' && e.status !== 'FAILED_PRECONDITION'))\n                    throw Error(e);\n            }\n            attempts--;\n        }\n    }\n    /**\n     * Query all all collections that match the given name that\n     * also are descendants of a given document (or root by default).\n     */\n    collectionGroup(collectionId, options = {}) {\n        return new Query(this.ref('parent' in options ? options.parent : ''), {\n            from: {\n                collectionId,\n                allDescendants: true\n            },\n            ...options\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}