{"ast":null,"code":"import { Document } from './Document';\nimport { isRef, isPositiveInteger, encodeValue } from './utils';\n/** @private */\n\nconst operatorsMap = {\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '==': 'EQUAL',\n  contains: 'ARRAY_CONTAINS',\n  'contains-any': 'ARRAY_CONTAINS_ANY',\n  in: 'IN'\n};\n/**\n * Checks if a value is a valid filter array.\n * @private\n */\n\nfunction validateFilter(filter) {\n  if (!Array.isArray(filter) || filter.length !== 3) throw Error('Filter missing arguments');\n  const [fieldPath, op, value] = filter;\n  if (typeof fieldPath !== 'string') throw Error('Invalid field path');\n  if (!(op in operatorsMap)) throw Error('Invalid operator');\n  if ((value === null || Number.isNaN(value)) && filter[1] !== '==') throw Error('Null and NaN can only be used with the == operator');\n  if (value === undefined) throw Error('Invalid comparative value');\n}\n/**\n * A map of functions used to encode each argument for a query.\n * Each function receives the Library arguments and returns an object\n * that will be converted to Json and sent to the Firestore REST API.\n * @private\n */\n\n\nconst encoders = {\n  /**\n   * Converts an option from the Query instance into a valid JSON\n   * object to use with the Firestores REST API.\n   */\n  select(fieldsArray) {\n    const fields = fieldsArray.map(fieldPath => ({\n      fieldPath\n    }));\n    return fields.length ? {\n      fields\n    } : undefined;\n  },\n\n  /** Converts a Query filter(array with three items), into an encoded filter */\n  encodeFilter([fieldPath, op, value]) {\n    if (Number.isNaN(value) || value === null) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath\n          },\n          op: Number.isNaN(value) ? 'IS_NAN' : 'IS_NULL'\n        }\n      };\n    }\n\n    return {\n      fieldFilter: {\n        field: {\n          fieldPath\n        },\n        op: operatorsMap[op],\n        value: encodeValue(value)\n      }\n    };\n  },\n\n  /**\n   * Converts an option from the Query instance into a valid JSON\n   * object to use with the Firestore's REST API.\n   */\n  where(option) {\n    if (option.length === 0) return;\n\n    if (option.length === 1) {\n      return this.encodeFilter(option[0]);\n    } // If there are more than one filters then this is a composite filter.\n\n\n    return {\n      compositeFilter: {\n        op: 'AND',\n        filters: option.map(this.encodeFilter)\n      }\n    };\n  },\n\n  /**\n   * When a startAt or endAt cursor is used,\n   * It is necessary to add a __name__ order at the end\n   * in order to make sure we start from the right spot.\n   */\n  orderBy(fields, options) {\n    var _a, _b, _c; // Only add the __name__ order if a cursor was provided\n    // and if its is not already present.\n\n\n    if ((options.startAt || options.endAt) && ((_a = fields[fields.length - 1]) === null || _a === void 0 ? void 0 : _a.field.fieldPath) !== '__name__') fields.push({\n      field: {\n        fieldPath: '__name__'\n      },\n      // Use the default order when there are no other fields,\n      // And if there are fields, use the order of the last one.\n      // This adheres to the spec at:\n      // https://firebase.google.com/docs/firestore/reference/rest/v1beta1/StructuredQuery\n      direction: (_c = (_b = fields[fields.length - 1]) === null || _b === void 0 ? void 0 : _b.direction) !== null && _c !== void 0 ? _c : 'ASCENDING'\n    });\n    return fields;\n  },\n\n  documentToCursor(doc, options) {\n    const values = [];\n\n    for (let order of options.orderBy) {\n      if (order.field.fieldPath === '__name__') {\n        values.push({\n          referenceValue: doc.__meta__.name\n        });\n        continue;\n      }\n\n      const value = doc[order.field.fieldPath];\n      value && values.push(encodeValue(value));\n    }\n\n    return {\n      values,\n      before: true\n    };\n  },\n\n  startAt(doc, options) {\n    return this.documentToCursor(doc, options);\n  },\n\n  endAt(doc, options) {\n    return this.startAt(doc, options);\n  }\n\n};\n/** @private */\n\nconst queryOptions = ['select', 'from', 'where', 'orderBy', 'startAt', 'endAt', 'offset', 'limit'];\n/**\n * Query class that represents a Firestore query.\n */\n\nexport class Query {\n  constructor(parent, init = {}) {\n    this.parent = parent;\n    this.options = {\n      select: [],\n      where: [],\n      orderBy: []\n    };\n    if (!isRef('doc', parent)) throw Error('Expected parent to be a reference to a document'); // Loop through all the valid options, validate them and then save them.\n\n    for (const option of queryOptions) {\n      const optionValue = init[option];\n\n      if (option in init) {\n        // If the option is \"where\" or \"orderBy\", and is also an array,\n        // then it might be a compound value, so we want to pass it one\n        // by one to its method.\n        //\n        // \"where\" is always an array, because every individual filter\n        // is represented by an array, so check to see if its first child\n        // is also an array. if it is, then it might be a compound value.\n        if (option === 'where' && Array.isArray(optionValue[0]) || option === 'orderBy' && Array.isArray(optionValue)) {\n          optionValue.forEach((val, i) => {\n            // Use try/catch in order to provide context for the error.\n            try {\n              // Try to save the value.\n              this[option](val);\n            } catch (e) {\n              throw Error(`Invalid argument \"${option}[${i}]\": ${e.message}`);\n            }\n          });\n          continue;\n        } // If the argument is not an array, then just save it directly.\n        // Again, we use try/catch to catch the error and add context to it.\n\n\n        try {\n          this[option](optionValue);\n        } catch (e) {\n          throw Error(`Invalid argument \"${option}\": ${e.message}`);\n        }\n      }\n    }\n  }\n\n  select(fields) {\n    if (!Array.isArray(fields)) throw Error('Expected argument to be an array of field paths');\n    fields.forEach((field, i) => {\n      if (typeof field !== 'string') throw Error(`Field path at index [${i}] is not a string`);\n      this.options.select.push(field);\n    });\n  }\n  /**\n   * Adds a collection to query.\n   */\n\n\n  from(from) {\n    let {\n      collectionId = from,\n      allDescendants\n    } = from;\n    if (typeof collectionId !== 'string') throw Error('Expected \"collectionId\" to be a string');\n    if (allDescendants !== undefined && typeof allDescendants !== 'boolean') throw Error('Expected the \"allDescendants\" to be a boolean');\n    this.options.from = {\n      collectionId,\n      allDescendants\n    };\n    return this;\n  }\n\n  where(fieldPath) {\n    const filter = Array.isArray(fieldPath) ? fieldPath : arguments;\n    validateFilter(filter);\n    this.options.where.push(filter);\n    return this;\n  }\n\n  orderBy(order, dir = 'asc') {\n    const dirMap = {\n      asc: 'ASCENDING',\n      desc: 'DESCENDING'\n    };\n    let {\n      field: fieldPath = order,\n      direction = dir\n    } = order;\n    direction = dirMap[direction];\n    if (typeof fieldPath !== 'string') throw Error('\"field\" property needs to be a string');\n    if (direction === undefined) throw Error('\"direction\" property can only be \"asc\" or \"desc\"');\n    this.options.orderBy.push({\n      field: {\n        fieldPath\n      },\n      direction\n    });\n    return this;\n  }\n\n  startAt(doc) {\n    if (!(doc instanceof Document)) throw Error('Expected a Document instance');\n    this.options.startAt = doc;\n    return this;\n  }\n\n  endAt(doc) {\n    if (!(doc instanceof Document)) throw Error('Expected a Document instance');\n    this.options.endAt = doc;\n    return this;\n  }\n\n  offset(number) {\n    if (!isPositiveInteger(number)) throw Error('Expected an integer that is greater than 0');\n    this.options.offset = number;\n    return this;\n  }\n\n  limit(number) {\n    if (!isPositiveInteger(number)) throw Error('Expected an integer that is greater than 0');\n    this.options.limit = number;\n    return this;\n  }\n\n  async run() {\n    var _a;\n\n    let results = await this.parent.db.fetch(this.parent.endpoint + ':runQuery', {\n      method: 'POST',\n      body: JSON.stringify(this)\n    });\n    ((_a = results[0]) === null || _a === void 0 ? void 0 : _a.document) || results.splice(0, 1);\n    return results.map(result => new Document(result.document, this.parent.db));\n  }\n\n  toJSON() {\n    const encoded = {};\n\n    for (const option in this.options) {\n      const optionValue = this.options[option];\n\n      if (option in encoders) {\n        encoded[option] = encoders[option](optionValue, this.options);\n        continue;\n      }\n\n      encoded[option] = optionValue;\n    }\n\n    return {\n      structuredQuery: encoded\n    };\n  }\n\n}","map":{"version":3,"sources":["/home/ana/Escritorio/EDUPLAN/telegram/proyecto-ana/proyecto/anny/node_modules/firebase-firestore-lite/dist/Query.js"],"names":["Document","isRef","isPositiveInteger","encodeValue","operatorsMap","contains","in","validateFilter","filter","Array","isArray","length","Error","fieldPath","op","value","Number","isNaN","undefined","encoders","select","fieldsArray","fields","map","encodeFilter","unaryFilter","field","fieldFilter","where","option","compositeFilter","filters","orderBy","options","_a","_b","_c","startAt","endAt","push","direction","documentToCursor","doc","values","order","referenceValue","__meta__","name","before","queryOptions","Query","constructor","parent","init","optionValue","forEach","val","i","e","message","from","collectionId","allDescendants","arguments","dir","dirMap","asc","desc","offset","number","limit","run","results","db","fetch","endpoint","method","body","JSON","stringify","document","splice","result","toJSON","encoded","structuredQuery"],"mappings":"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","sourcesContent":["import { Document } from './Document';\nimport { isRef, isPositiveInteger, encodeValue } from './utils';\n/** @private */\nconst operatorsMap = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    contains: 'ARRAY_CONTAINS',\n    'contains-any': 'ARRAY_CONTAINS_ANY',\n    in: 'IN'\n};\n/**\n * Checks if a value is a valid filter array.\n * @private\n */\nfunction validateFilter(filter) {\n    if (!Array.isArray(filter) || filter.length !== 3)\n        throw Error('Filter missing arguments');\n    const [fieldPath, op, value] = filter;\n    if (typeof fieldPath !== 'string')\n        throw Error('Invalid field path');\n    if (!(op in operatorsMap))\n        throw Error('Invalid operator');\n    if ((value === null || Number.isNaN(value)) && filter[1] !== '==')\n        throw Error('Null and NaN can only be used with the == operator');\n    if (value === undefined)\n        throw Error('Invalid comparative value');\n}\n/**\n * A map of functions used to encode each argument for a query.\n * Each function receives the Library arguments and returns an object\n * that will be converted to Json and sent to the Firestore REST API.\n * @private\n */\nconst encoders = {\n    /**\n     * Converts an option from the Query instance into a valid JSON\n     * object to use with the Firestores REST API.\n     */\n    select(fieldsArray) {\n        const fields = fieldsArray.map(fieldPath => ({ fieldPath }));\n        return fields.length ? { fields } : undefined;\n    },\n    /** Converts a Query filter(array with three items), into an encoded filter */\n    encodeFilter([fieldPath, op, value]) {\n        if (Number.isNaN(value) || value === null) {\n            return {\n                unaryFilter: {\n                    field: { fieldPath },\n                    op: Number.isNaN(value) ? 'IS_NAN' : 'IS_NULL'\n                }\n            };\n        }\n        return {\n            fieldFilter: {\n                field: { fieldPath },\n                op: operatorsMap[op],\n                value: encodeValue(value)\n            }\n        };\n    },\n    /**\n     * Converts an option from the Query instance into a valid JSON\n     * object to use with the Firestore's REST API.\n     */\n    where(option) {\n        if (option.length === 0)\n            return;\n        if (option.length === 1) {\n            return this.encodeFilter(option[0]);\n        }\n        // If there are more than one filters then this is a composite filter.\n        return {\n            compositeFilter: {\n                op: 'AND',\n                filters: option.map(this.encodeFilter)\n            }\n        };\n    },\n    /**\n     * When a startAt or endAt cursor is used,\n     * It is necessary to add a __name__ order at the end\n     * in order to make sure we start from the right spot.\n     */\n    orderBy(fields, options) {\n        var _a, _b, _c;\n        // Only add the __name__ order if a cursor was provided\n        // and if its is not already present.\n        if ((options.startAt || options.endAt) &&\n            ((_a = fields[fields.length - 1]) === null || _a === void 0 ? void 0 : _a.field.fieldPath) !== '__name__')\n            fields.push({\n                field: { fieldPath: '__name__' },\n                // Use the default order when there are no other fields,\n                // And if there are fields, use the order of the last one.\n                // This adheres to the spec at:\n                // https://firebase.google.com/docs/firestore/reference/rest/v1beta1/StructuredQuery\n                direction: (_c = (_b = fields[fields.length - 1]) === null || _b === void 0 ? void 0 : _b.direction) !== null && _c !== void 0 ? _c : 'ASCENDING'\n            });\n        return fields;\n    },\n    documentToCursor(doc, options) {\n        const values = [];\n        for (let order of options.orderBy) {\n            if (order.field.fieldPath === '__name__') {\n                values.push({ referenceValue: doc.__meta__.name });\n                continue;\n            }\n            const value = doc[order.field.fieldPath];\n            value && values.push(encodeValue(value));\n        }\n        return {\n            values,\n            before: true\n        };\n    },\n    startAt(doc, options) {\n        return this.documentToCursor(doc, options);\n    },\n    endAt(doc, options) {\n        return this.startAt(doc, options);\n    }\n};\n/** @private */\nconst queryOptions = [\n    'select',\n    'from',\n    'where',\n    'orderBy',\n    'startAt',\n    'endAt',\n    'offset',\n    'limit'\n];\n/**\n * Query class that represents a Firestore query.\n */\nexport class Query {\n    constructor(parent, init = {}) {\n        this.parent = parent;\n        this.options = {\n            select: [],\n            where: [],\n            orderBy: []\n        };\n        if (!isRef('doc', parent))\n            throw Error('Expected parent to be a reference to a document');\n        // Loop through all the valid options, validate them and then save them.\n        for (const option of queryOptions) {\n            const optionValue = init[option];\n            if (option in init) {\n                // If the option is \"where\" or \"orderBy\", and is also an array,\n                // then it might be a compound value, so we want to pass it one\n                // by one to its method.\n                //\n                // \"where\" is always an array, because every individual filter\n                // is represented by an array, so check to see if its first child\n                // is also an array. if it is, then it might be a compound value.\n                if ((option === 'where' && Array.isArray(optionValue[0])) ||\n                    (option === 'orderBy' && Array.isArray(optionValue))) {\n                    optionValue.forEach((val, i) => {\n                        // Use try/catch in order to provide context for the error.\n                        try {\n                            // Try to save the value.\n                            this[option](val);\n                        }\n                        catch (e) {\n                            throw Error(`Invalid argument \"${option}[${i}]\": ${e.message}`);\n                        }\n                    });\n                    continue;\n                }\n                // If the argument is not an array, then just save it directly.\n                // Again, we use try/catch to catch the error and add context to it.\n                try {\n                    this[option](optionValue);\n                }\n                catch (e) {\n                    throw Error(`Invalid argument \"${option}\": ${e.message}`);\n                }\n            }\n        }\n    }\n    select(fields) {\n        if (!Array.isArray(fields))\n            throw Error('Expected argument to be an array of field paths');\n        fields.forEach((field, i) => {\n            if (typeof field !== 'string')\n                throw Error(`Field path at index [${i}] is not a string`);\n            this.options.select.push(field);\n        });\n    }\n    /**\n     * Adds a collection to query.\n     */\n    from(from) {\n        let { collectionId = from, allDescendants } = from;\n        if (typeof collectionId !== 'string')\n            throw Error('Expected \"collectionId\" to be a string');\n        if (allDescendants !== undefined && typeof allDescendants !== 'boolean')\n            throw Error('Expected the \"allDescendants\" to be a boolean');\n        this.options.from = {\n            collectionId,\n            allDescendants\n        };\n        return this;\n    }\n    where(fieldPath) {\n        const filter = Array.isArray(fieldPath) ? fieldPath : arguments;\n        validateFilter(filter);\n        this.options.where.push(filter);\n        return this;\n    }\n    orderBy(order, dir = 'asc') {\n        const dirMap = {\n            asc: 'ASCENDING',\n            desc: 'DESCENDING'\n        };\n        let { field: fieldPath = order, direction = dir } = order;\n        direction = dirMap[direction];\n        if (typeof fieldPath !== 'string')\n            throw Error('\"field\" property needs to be a string');\n        if (direction === undefined)\n            throw Error('\"direction\" property can only be \"asc\" or \"desc\"');\n        this.options.orderBy.push({ field: { fieldPath }, direction });\n        return this;\n    }\n    startAt(doc) {\n        if (!(doc instanceof Document))\n            throw Error('Expected a Document instance');\n        this.options.startAt = doc;\n        return this;\n    }\n    endAt(doc) {\n        if (!(doc instanceof Document))\n            throw Error('Expected a Document instance');\n        this.options.endAt = doc;\n        return this;\n    }\n    offset(number) {\n        if (!isPositiveInteger(number))\n            throw Error('Expected an integer that is greater than 0');\n        this.options.offset = number;\n        return this;\n    }\n    limit(number) {\n        if (!isPositiveInteger(number))\n            throw Error('Expected an integer that is greater than 0');\n        this.options.limit = number;\n        return this;\n    }\n    async run() {\n        var _a;\n        let results = await this.parent.db.fetch(this.parent.endpoint + ':runQuery', {\n            method: 'POST',\n            body: JSON.stringify(this)\n        });\n        ((_a = results[0]) === null || _a === void 0 ? void 0 : _a.document) || results.splice(0, 1);\n        return results.map((result) => new Document(result.document, this.parent.db));\n    }\n    toJSON() {\n        const encoded = {};\n        for (const option in this.options) {\n            const optionValue = this.options[option];\n            if (option in encoders) {\n                encoded[option] = encoders[option](optionValue, this.options);\n                continue;\n            }\n            encoded[option] = optionValue;\n        }\n        return {\n            structuredQuery: encoded\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}